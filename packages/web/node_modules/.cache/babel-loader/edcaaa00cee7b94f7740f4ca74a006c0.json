{"ast":null,"code":"import { isArgumentElement, isDateElement, isDateTimeSkeleton, isLiteralElement, isNumberElement, isNumberSkeleton, isPluralElement, isPoundElement, isSelectElement, isTimeElement, isTagElement } from '@formatjs/icu-messageformat-parser';\nimport { MissingValueError, InvalidValueError, ErrorCode, FormatError, InvalidValueTypeError } from './error';\nexport var PART_TYPE;\n(function (PART_TYPE) {\n  PART_TYPE[PART_TYPE[\"literal\"] = 0] = \"literal\";\n  PART_TYPE[PART_TYPE[\"object\"] = 1] = \"object\";\n})(PART_TYPE || (PART_TYPE = {}));\nfunction mergeLiteral(parts) {\n  if (parts.length < 2) {\n    return parts;\n  }\n  return parts.reduce(function (all, part) {\n    var lastPart = all[all.length - 1];\n    if (!lastPart || lastPart.type !== PART_TYPE.literal || part.type !== PART_TYPE.literal) {\n      all.push(part);\n    } else {\n      lastPart.value += part.value;\n    }\n    return all;\n  }, []);\n}\nexport function isFormatXMLElementFn(el) {\n  return typeof el === 'function';\n}\n// TODO(skeleton): add skeleton support\nexport function formatToParts(els, locales, formatters, formats, values, currentPluralValue,\n// For debugging\noriginalMessage) {\n  // Hot path for straight simple msg translations\n  if (els.length === 1 && isLiteralElement(els[0])) {\n    return [{\n      type: PART_TYPE.literal,\n      value: els[0].value\n    }];\n  }\n  var result = [];\n  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n    var el = els_1[_i];\n    // Exit early for string parts.\n    if (isLiteralElement(el)) {\n      result.push({\n        type: PART_TYPE.literal,\n        value: el.value\n      });\n      continue;\n    }\n    // TODO: should this part be literal type?\n    // Replace `#` in plural rules with the actual numeric value.\n    if (isPoundElement(el)) {\n      if (typeof currentPluralValue === 'number') {\n        result.push({\n          type: PART_TYPE.literal,\n          value: formatters.getNumberFormat(locales).format(currentPluralValue)\n        });\n      }\n      continue;\n    }\n    var varName = el.value;\n    // Enforce that all required values are provided by the caller.\n    if (!(values && varName in values)) {\n      throw new MissingValueError(varName, originalMessage);\n    }\n    var value = values[varName];\n    if (isArgumentElement(el)) {\n      if (!value || typeof value === 'string' || typeof value === 'number') {\n        value = typeof value === 'string' || typeof value === 'number' ? String(value) : '';\n      }\n      result.push({\n        type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n        value: value\n      });\n      continue;\n    }\n    // Recursively format plural and select parts' option â€” which can be a\n    // nested pattern structure. The choosing of the option to use is\n    // abstracted-by and delegated-to the part helper object.\n    if (isDateElement(el)) {\n      var style = typeof el.style === 'string' ? formats.date[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : undefined;\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n    if (isTimeElement(el)) {\n      var style = typeof el.style === 'string' ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? el.style.parsedOptions : formats.time.medium;\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getDateTimeFormat(locales, style).format(value)\n      });\n      continue;\n    }\n    if (isNumberElement(el)) {\n      var style = typeof el.style === 'string' ? formats.number[el.style] : isNumberSkeleton(el.style) ? el.style.parsedOptions : undefined;\n      if (style && style.scale) {\n        value = value * (style.scale || 1);\n      }\n      result.push({\n        type: PART_TYPE.literal,\n        value: formatters.getNumberFormat(locales, style).format(value)\n      });\n      continue;\n    }\n    if (isTagElement(el)) {\n      var children = el.children,\n        value_1 = el.value;\n      var formatFn = values[value_1];\n      if (!isFormatXMLElementFn(formatFn)) {\n        throw new InvalidValueTypeError(value_1, 'function', originalMessage);\n      }\n      var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);\n      var chunks = formatFn(parts.map(function (p) {\n        return p.value;\n      }));\n      if (!Array.isArray(chunks)) {\n        chunks = [chunks];\n      }\n      result.push.apply(result, chunks.map(function (c) {\n        return {\n          type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,\n          value: c\n        };\n      }));\n    }\n    if (isSelectElement(el)) {\n      var opt = el.options[value] || el.options.other;\n      if (!opt) {\n        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));\n      continue;\n    }\n    if (isPluralElement(el)) {\n      var opt = el.options[\"=\".concat(value)];\n      if (!opt) {\n        if (!Intl.PluralRules) {\n          throw new FormatError(\"Intl.PluralRules is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-pluralrules\\\"\\n\", ErrorCode.MISSING_INTL_API, originalMessage);\n        }\n        var rule = formatters.getPluralRules(locales, {\n          type: el.pluralType\n        }).select(value - (el.offset || 0));\n        opt = el.options[rule] || el.options.other;\n      }\n      if (!opt) {\n        throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);\n      }\n      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));\n      continue;\n    }\n  }\n  return mergeLiteral(result);\n}","map":null,"metadata":{},"sourceType":"module"}