{"ast":null,"code":"ace.define(\"ace/mode/abap_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  /*\n  * based on\n  * \" Vim ABAP syntax file\n  * \"    Language: SAP - ABAP/R4\n  * \"    Revision: 2.1\n  * \"  Maintainer: Marius Piedallu van Wyk <lailoken@gmail.com>\n  * \" Last Change: 2012 Oct 23\n  */\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n  var AbapHighlightRules = function AbapHighlightRules() {\n    var keywordMapper = this.createKeywordMapper({\n      \"variable.language\": \"this\",\n      \"keyword\": \"ADD ALIAS ALIASES ASCENDING ASSERT ASSIGN ASSIGNING AT BACK\" + \" CALL CASE CATCH CHECK CLASS CLEAR CLOSE CNT COLLECT COMMIT COMMUNICATION COMPUTE CONCATENATE CONDENSE CONSTANTS CONTINUE CONTROLS CONVERT CREATE CURRENCY\" + \" DATA DEFINE DEFINITION DEFERRED DELETE DESCENDING DESCRIBE DETAIL DIVIDE DO\" + \" ELSE ELSEIF ENDAT ENDCASE ENDCLASS ENDDO ENDEXEC ENDFORM ENDFUNCTION ENDIF ENDIFEND ENDINTERFACE ENDLOOP ENDMETHOD ENDMODULE ENDON ENDPROVIDE ENDSELECT ENDTRY ENDWHILE EVENT EVENTS EXEC EXIT EXPORT EXPORTING EXTRACT\" + \" FETCH FIELDS FORM FORMAT FREE FROM FUNCTION\" + \" GENERATE GET\" + \" HIDE\" + \" IF IMPORT IMPORTING INDEX INFOTYPES INITIALIZATION INTERFACE INTERFACES INPUT INSERT IMPLEMENTATION\" + \" LEAVE LIKE LINE LOAD LOCAL LOOP\" + \" MESSAGE METHOD METHODS MODIFY MODULE MOVE MULTIPLY\" + \" ON OVERLAY OPTIONAL OTHERS\" + \" PACK PARAMETERS PERFORM POSITION PROGRAM PROVIDE PUT\" + \" RAISE RANGES READ RECEIVE RECEIVING REDEFINITION REFERENCE REFRESH REJECT REPLACE REPORT RESERVE RESTORE RETURN RETURNING ROLLBACK\" + \" SCAN SCROLL SEARCH SELECT SET SHIFT SKIP SORT SORTED SPLIT STANDARD STATICS STEP STOP SUBMIT SUBTRACT SUM SUMMARY SUPPRESS\" + \" TABLES TIMES TRANSFER TRANSLATE TRY TYPE TYPES\" + \" UNASSIGN ULINE UNPACK UPDATE\" + \" WHEN WHILE WINDOW WRITE\" + \" OCCURS STRUCTURE OBJECT PROPERTY\" + \" CASTING APPEND RAISING VALUE COLOR\" + \" CHANGING EXCEPTION EXCEPTIONS DEFAULT CHECKBOX COMMENT\" + \" ID NUMBER FOR TITLE OUTPUT\" + \" WITH EXIT USING\" + \" INTO WHERE GROUP BY HAVING ORDER BY SINGLE\" + \" APPENDING CORRESPONDING FIELDS OF TABLE\" + \" LEFT RIGHT OUTER INNER JOIN AS CLIENT SPECIFIED BYPASSING BUFFER UP TO ROWS CONNECTING\" + \" EQ NE LT LE GT GE NOT AND OR XOR IN LIKE BETWEEN\",\n      \"constant.language\": \"TRUE FALSE NULL SPACE\",\n      \"support.type\": \"c n i p f d t x string xstring decfloat16 decfloat34\",\n      \"keyword.operator\": \"abs sign ceil floor trunc frac acos asin atan cos sin tan\" + \" abapOperator cosh sinh tanh exp log log10 sqrt\" + \" strlen xstrlen charlen numofchar dbmaxlen lines\"\n    }, \"text\", true, \" \");\n    var compoundKeywords = \"WITH\\\\W+(?:HEADER\\\\W+LINE|FRAME|KEY)|NO\\\\W+STANDARD\\\\W+PAGE\\\\W+HEADING|\" + \"EXIT\\\\W+FROM\\\\W+STEP\\\\W+LOOP|BEGIN\\\\W+OF\\\\W+(?:BLOCK|LINE)|BEGIN\\\\W+OF|\" + \"END\\\\W+OF\\\\W+(?:BLOCK|LINE)|END\\\\W+OF|NO\\\\W+INTERVALS|\" + \"RESPECTING\\\\W+BLANKS|SEPARATED\\\\W+BY|USING\\\\W+(?:EDIT\\\\W+MASK)|\" + \"WHERE\\\\W+(?:LINE)|RADIOBUTTON\\\\W+GROUP|REF\\\\W+TO|\" + \"(?:PUBLIC|PRIVATE|PROTECTED)(?:\\\\W+SECTION)?|DELETING\\\\W+(?:TRAILING|LEADING)\" + \"(?:ALL\\\\W+OCCURRENCES)|(?:FIRST|LAST)\\\\W+OCCURRENCE|INHERITING\\\\W+FROM|\" + \"LINE-COUNT|ADD-CORRESPONDING|AUTHORITY-CHECK|BREAK-POINT|CLASS-DATA|CLASS-METHODS|\" + \"CLASS-METHOD|DIVIDE-CORRESPONDING|EDITOR-CALL|END-OF-DEFINITION|END-OF-PAGE|END-OF-SELECTION|\" + \"FIELD-GROUPS|FIELD-SYMBOLS|FUNCTION-POOL|MOVE-CORRESPONDING|MULTIPLY-CORRESPONDING|NEW-LINE|\" + \"NEW-PAGE|NEW-SECTION|PRINT-CONTROL|RP-PROVIDE-FROM-LAST|SELECT-OPTIONS|SELECTION-SCREEN|\" + \"START-OF-SELECTION|SUBTRACT-CORRESPONDING|SYNTAX-CHECK|SYNTAX-TRACE|TOP-OF-PAGE|TYPE-POOL|\" + \"TYPE-POOLS|LINE-SIZE|LINE-COUNT|MESSAGE-ID|DISPLAY-MODE|READ(?:-ONLY)?|\" + \"IS\\\\W+(?:NOT\\\\W+)?(?:ASSIGNED|BOUND|INITIAL|SUPPLIED)\";\n    this.$rules = {\n      \"start\": [{\n        token: \"string\",\n        regex: \"`\",\n        next: \"string\"\n      }, {\n        token: \"string\",\n        regex: \"'\",\n        next: \"qstring\"\n      }, {\n        token: \"doc.comment\",\n        regex: /^\\*.+/\n      }, {\n        token: \"comment\",\n        regex: /\".+$/\n      }, {\n        token: \"invalid\",\n        regex: \"\\\\.{2,}\"\n      }, {\n        token: \"keyword.operator\",\n        regex: /\\W[\\-+%=<>*]\\W|\\*\\*|[~:,\\.&$]|->*?|=>/\n      }, {\n        token: \"paren.lparen\",\n        regex: \"[\\\\[({]\"\n      }, {\n        token: \"paren.rparen\",\n        regex: \"[\\\\])}]\"\n      }, {\n        token: \"constant.numeric\",\n        regex: \"[+-]?\\\\d+\\\\b\"\n      }, {\n        token: \"variable.parameter\",\n        regex: /sy|pa?\\d\\d\\d\\d\\|t\\d\\d\\d\\.|innnn/\n      }, {\n        token: \"keyword\",\n        regex: compoundKeywords\n      }, {\n        token: \"variable.parameter\",\n        regex: /\\w+-\\w[\\-\\w]*/\n      }, {\n        token: keywordMapper,\n        regex: \"\\\\b\\\\w+\\\\b\"\n      }, {\n        caseInsensitive: true\n      }],\n      \"qstring\": [{\n        token: \"constant.language.escape\",\n        regex: \"''\"\n      }, {\n        token: \"string\",\n        regex: \"'\",\n        next: \"start\"\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"string\": [{\n        token: \"constant.language.escape\",\n        regex: \"``\"\n      }, {\n        token: \"string\",\n        regex: \"`\",\n        next: \"start\"\n      }, {\n        defaultToken: \"string\"\n      }]\n    };\n  };\n  oop.inherits(AbapHighlightRules, TextHighlightRules);\n  exports.AbapHighlightRules = AbapHighlightRules;\n});\nace.define(\"ace/mode/folding/coffee\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n  var Range = require(\"../../range\").Range;\n  var FoldMode = exports.FoldMode = function () {};\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var range = this.indentationBlock(session, row);\n      if (range) return range;\n      var re = /\\S/;\n      var line = session.getLine(row);\n      var startLevel = line.search(re);\n      if (startLevel == -1 || line[startLevel] != \"#\") return;\n      var startColumn = line.length;\n      var maxRow = session.getLength();\n      var startRow = row;\n      var endRow = row;\n      while (++row < maxRow) {\n        line = session.getLine(row);\n        var level = line.search(re);\n        if (level == -1) continue;\n        if (line[level] != \"#\") break;\n        endRow = row;\n      }\n      if (endRow > startRow) {\n        var endColumn = session.getLine(endRow).length;\n        return new Range(startRow, startColumn, endRow, endColumn);\n      }\n    };\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var indent = line.search(/\\S/);\n      var next = session.getLine(row + 1);\n      var prev = session.getLine(row - 1);\n      var prevIndent = prev.search(/\\S/);\n      var nextIndent = next.search(/\\S/);\n      if (indent == -1) {\n        session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? \"start\" : \"\";\n        return \"\";\n      }\n      if (prevIndent == -1) {\n        if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n          session.foldWidgets[row - 1] = \"\";\n          session.foldWidgets[row + 1] = \"\";\n          return \"start\";\n        }\n      } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n        if (session.getLine(row - 2).search(/\\S/) == -1) {\n          session.foldWidgets[row - 1] = \"start\";\n          session.foldWidgets[row + 1] = \"\";\n          return \"\";\n        }\n      }\n      if (prevIndent != -1 && prevIndent < indent) session.foldWidgets[row - 1] = \"start\";else session.foldWidgets[row - 1] = \"\";\n      if (indent < nextIndent) return \"start\";else return \"\";\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/abap\", [\"require\", \"exports\", \"module\", \"ace/mode/abap_highlight_rules\", \"ace/mode/folding/coffee\", \"ace/range\", \"ace/mode/text\", \"ace/lib/oop\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Rules = require(\"./abap_highlight_rules\").AbapHighlightRules;\n  var FoldMode = require(\"./folding/coffee\").FoldMode;\n  var Range = require(\"../range\").Range;\n  var TextMode = require(\"./text\").Mode;\n  var oop = require(\"../lib/oop\");\n  function Mode() {\n    this.HighlightRules = Rules;\n    this.foldingRules = new FoldMode();\n  }\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = '\"';\n    this.getNextLineIndent = function (state, line, tab) {\n      var indent = this.$getIndent(line);\n      return indent;\n    };\n    this.$id = \"ace/mode/abap\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n(function () {\n  ace.require([\"ace/mode/abap\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}